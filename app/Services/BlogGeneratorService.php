<?php

namespace App\Services;

use App\Models\Blog;
use App\Models\Category;
use Illuminate\Support\Str;
use Illuminate\Support\Facades\Log;

class BlogGeneratorService
{
    protected $scraper;
    protected $ai;
    protected $thumbnailService;
    protected $titleSanitizer;

    public function __construct(
        ScrapingService $scraper, 
        AIService $ai, 
        \App\Services\ThumbnailService $thumbnailService,
        TitleSanitizerService $titleSanitizer
    )
    {
        $this->scraper = $scraper;
        $this->ai = $ai;
        $this->thumbnailService = $thumbnailService;
        $this->titleSanitizer = $titleSanitizer;
    }

    public function generateBlogForCategory(Category $category, ?callable $onProgress = null)
    {
        $onProgress && $onProgress('Scraping trending topics...', 10);
        // 1. Get Topics
        $topics = $this->scraper->fetchTrendingTopics($category->slug);
        $topic = $topics[array_rand($topics)];

        // Check duplicates
        if (Blog::where('title', 'LIKE', "%$topic%")->exists()) {
            Log::info("Skipping duplicate topic: $topic");
            $onProgress && $onProgress('Duplicate topic found, retrying...', 15);
            return null;
        }

        $onProgress && $onProgress("Researching topic: $topic...", 30);
        // 2. Multi-Source Research
        Log::info("Researching topic: $topic");
        $researchData = $this->scraper->researchTopic($topic);
        
        $onProgress && $onProgress('Generating draft with AI...', 50);
        // 3. Generate Draft with new AI service
        $draft = $this->ai->generateRawContent($topic, $category->name, $researchData);

        $onProgress && $onProgress('Optimizing and humanizing content...', 70);
        // 4. Optimize and Humanize (returns ['content' => string, 'toc' => array])
        $optimizedData = $this->ai->optimizeAndHumanize($draft);
        $finalContent = $optimizedData['content'];
        $toc = $optimizedData['toc'];
        
        // 5. Validate content
        $wordCount = str_word_count(strip_tags($finalContent));
        Log::info("Blog generated: $wordCount words");
        
        // 5c. Link Management & Validation
        // Validate external links generated by AI
        $cleanedData = $this->validateAndCleanLinks($finalContent);
        $finalContent = $cleanedData['html'];
        
        // Internal Linking (Balance with External)
        // Count current external links
        $externalLinkCount = substr_count($finalContent, 'href="http');
        
        // Cap total links to 8 (so if 3 external, we can add up to 5 internal, but we limit internal to 3 anyway)
        $limitInternal = min(3, 8 - $externalLinkCount);
        
        if ($limitInternal > 0) {
            $relatedBlogs = Blog::where('category_id', $category->id)
                ->where('id', '!=', $category->id) 
                ->latest()
                ->take($limitInternal)
                ->get();
                
            if ($relatedBlogs->count() > 0) {
                 $internalData = $this->insertInternalLinks($finalContent, $relatedBlogs);
                 $finalContent = $internalData['html'];
            }
        }

        // 6. Extract Title
        $title = $topic;
        if (preg_match('/<h1[^>]*>(.*?)<\/h1>/', $finalContent, $matches)) {
            $title = strip_tags($matches[1]);
        }
        
        // Sanitize title to remove entities
        $title = $this->titleSanitizer->sanitizeTitle($title);

        // 7. Generate slug
        $slug = Str::slug($title . '-' . now()->timestamp);

        // 8. Create Blog record first to get ID
        $onProgress && $onProgress('Saving initial record...', 85);
        $blog = Blog::create([
            'title' => $title,
            'slug' => $slug,
            'content' => $finalContent,
            'category_id' => $category->id,
            'published_at' => now(),
             // Enhanced SEO Meta
            'meta_title' => Str::limit($title, 55) . ' - ' . config('app.name', 'AutoBlog'),
            'meta_description' => Str::limit(strip_tags($finalContent), 155),
            'tags_json' => [$category->name, 'Trending', $topic, date('Y')],
            'table_of_contents_json' => $toc,
            'thumbnail_path' => null, // Placeholder
        ]);

        $onProgress && $onProgress('Generating thumbnail...', 90);
        // 9. Generate thumbnail with ID
        $thumbnailPath = $this->thumbnailService->generateThumbnail(
            $slug,
            $title,
            $finalContent,
            $category->name,
            $blog->id // Pass the ID
        );

        // 10. Update blog with actual thumbnail
        $blog->update(['thumbnail_path' => $thumbnailPath]);
        
        // Double-check and fix any issues (e.g. if title logic changed post-creation)
        $this->titleSanitizer->fixBlog($blog);
        
        $onProgress && $onProgress('Done!', 100);
        
        return $blog;
    }

    public function processSeoLinks(string $content, Category $category): array
    {
        // 1. Validate & Clean External Links
        $cleanedData = $this->validateAndCleanLinks($content);
        $content = $cleanedData['html'];
        $externalCount = $cleanedData['count'];
        $linkLogs = $cleanedData['logs'] ?? [];
        if ($externalCount < 2) {
             // Retroactive Link Injection via AI
             // This is expensive/slow, but required for "Fix" command to actually work on old blogs.
             $contentWithLinks = $this->ai->injectSmartLinks($content);
             
             // Validate AGAIN to ensure AI didn't add junk
             $cleanedData = $this->validateAndCleanLinks($contentWithLinks);
             $content = $cleanedData['html'];
             $externalCount = $cleanedData['count'];
             // Merge logs?
             $linkLogs = array_merge($linkLogs, $cleanedData['logs'] ?? []);
        }

        // 2. Insert Internal Links if room
        $externalLinkCount = $externalCount; // Use the updated count
        $limitInternal = min(3, 8 - $externalLinkCount);
        $internalCount = 0;
        
        if ($limitInternal > 0) {
            $relatedBlogs = Blog::where('category_id', $category->id)
                ->where('id', '!=', $category->id)
                ->latest()
                ->take($limitInternal)
                ->get();
                
            if ($relatedBlogs->count() > 0) {
                 $internalData = $this->insertInternalLinks($content, $relatedBlogs);
                 $content = $internalData['html'];
                 $internalCount = $internalData['count'];
            }
        }
        
        return [
            'html' => $content,
            'external_count' => $externalCount,
            'internal_count' => $internalCount,
            'logs' => $linkLogs
        ];
    }

    protected function insertInternalLinks(string $html, $relatedBlogs): array
    {
        if ($relatedBlogs->isEmpty()) {
            return ['html' => $html, 'count' => 0];
        }

        $dom = new \DOMDocument();
        libxml_use_internal_errors(true);
        $dom->loadHTML('<?xml encoding="utf-8" ?>' . $html, LIBXML_HTML_NOIMPLIED | LIBXML_HTML_NODEFDTD);
        libxml_clear_errors();
        
        $paragraphs = $dom->getElementsByTagName('p');
        $pCount = $paragraphs->length;
        $injectedCount = 0;
        
        // Distribute links: one after 1st para, one in middle, one near end (approx)
        $positions = [
            1, 
            (int)($pCount / 2), 
            $pCount - 2
        ];
        
        $blogIndex = 0;
        
        foreach ($positions as $index) {
             if ($blogIndex >= $relatedBlogs->count()) break;
             if ($index < 0 || $index >= $pCount) continue;
             
             $targetP = $paragraphs->item($index);
             if ($targetP) {
                 $blog = $relatedBlogs[$blogIndex];
                 
                 // Create link phrasing
                 $phrases = [
                     "For more details, check out <a href='%s' rel='dofollow'>%s</a>.",
                     "You might also like: <a href='%s' rel='dofollow'>%s</a>.",
                     "Related reading: <a href='%s' rel='dofollow'>%s</a>."
                 ];
                 $phrase = sprintf($phrases[$blogIndex % 3], route('blog.show', $blog->slug), $blog->title);
                 
                 $newP = $dom->createElement('p');
                 // Load HTML fragment for the link
                 $frag = $dom->createDocumentFragment();
                 $frag->appendXML("<em>$phrase</em>");
                 $newP->appendChild($frag);
                 
                 $targetP->parentNode->insertBefore($newP, $targetP->nextSibling);
                 $blogIndex++;
                 $injectedCount++;
             }
        }
        
        $fixed = $dom->saveHTML();
        return [
            'html' => str_replace('<?xml encoding="utf-8" ?>', '', $fixed),
            'count' => $injectedCount
        ];
    }

    protected function validateAndCleanLinks(string $html): array
    {
        $dom = new \DOMDocument();
        libxml_use_internal_errors(true);
        // Ensure UTF-8 is handled correctly
        $dom->loadHTML('<?xml encoding="utf-8" ?>' . $html, LIBXML_HTML_NOIMPLIED | LIBXML_HTML_NODEFDTD);
        libxml_clear_errors();
        
        $xpath = new \DOMXPath($dom);
        $links = $xpath->query('//a');
        $validLinksCount = 0;
        $maxExternal = 4;
        $logs = [];
        
        foreach ($links as $link) {
            $href = $link->getAttribute('href');
            
            // Skip internal or empty links
            if (empty($href) || str_starts_with($href, '/') || str_starts_with($href, '#') || str_contains($href, config('app.url'))) {
                continue;
            }
            
            // Validate URL (Headless check)
            $validation = $this->isValidUrl($href, true); // Pass true for detailed result
            
            if ($validation['valid']) {
                $validLinksCount++;
                // Ensure dofollow
                $link->setAttribute('rel', 'dofollow');
                $link->setAttribute('target', '_blank'); // Safety
                
                // Cap external links
                if ($validLinksCount > $maxExternal) {
                    $logs[] = "Removed (Limit): $href";
                    // Convert to plain text if over limit
                    $text = $dom->createTextNode($link->textContent);
                    $link->parentNode->replaceChild($text, $link);
                    $validLinksCount--; // Adjust count as we removed it
                } else {
                    $logs[] = "Valid: $href";
                }
            } else {
                // Remove invalid link, keep text
                $reason = $validation['reason'] ?? 'Unknown';
                $logs[] = "Removed ($reason): $href";
                Log::warning("Removing invalid link: $href. Reason: $reason");
                $text = $dom->createTextNode($link->textContent);
                $link->parentNode->replaceChild($text, $link);
            }
        }
        
        $fixed = $dom->saveHTML();
        return [
            'html' => str_replace('<?xml encoding="utf-8" ?>', '', $fixed),
            'count' => $validLinksCount,
            'logs' => $logs
        ];
    }
    
    protected function isValidUrl(string $url, bool $returnDetails = false)
    {
        // Simple filter var check first
        if (!filter_var($url, FILTER_VALIDATE_URL)) {
             return $returnDetails ? ['valid' => false, 'reason' => 'Invalid Format'] : false;
        }
        
        // Perform a quick HEAD request
        try {
             // Use stream context for timeout and USER AGENT
            $context = stream_context_create([
                'http' => [
                    'method' => 'HEAD', 
                    'timeout' => 5, // Increased timeout to 5s
                    'ignore_errors' => true,
                    'user_agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
                ]
            ]);
            
            // Suppress errors but catch them via error_get_last if needed, or just exception check
            $headers = @get_headers($url, 0, $context);
            
            if (!$headers || empty($headers)) {
                 // Fallback to GET
                 $context = stream_context_create([
                    'http' => [
                        'method' => 'GET', 
                        'timeout' => 5, 
                        'ignore_errors' => true,
                        'user_agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
                    ]
                ]);
                $headers = @get_headers($url, 0, $context);
            }

            if (!$headers || empty($headers)) {
                 return $returnDetails ? ['valid' => false, 'reason' => 'No Headers/Connection Failed'] : false;
            }

            // Check status code
            // $headers[0] e.g. "HTTP/1.1 200 OK"
            $statusLine = $headers[0];
            preg_match('/HTTP\/\S+\s(\d{3})/', $statusLine, $matches);
            $code = isset($matches[1]) ? (int)$matches[1] : 0;
            
            if ($code >= 200 && $code < 400) {
                return $returnDetails ? ['valid' => true] : true;
            }
            
            if ($code === 403 || $code === 429) {
                 // Some sites block programmatic access 100%. 
                 // If it's 403, it MIGHT be valid but we are blocked. 
                 // Users prefer functional links. If we can't check it, is it risky to keep it?
                 // Let's assume strict: if we can't verify, we remove.
                 return $returnDetails ? ['valid' => false, 'reason' => "Status $code"] : false;
            }
             
             return $returnDetails ? ['valid' => false, 'reason' => "Status $code"] : false;

        } catch (\Exception $e) {
            return $returnDetails ? ['valid' => false, 'reason' => 'Exception: ' . $e->getMessage()] : false;
        }
        
        return $returnDetails ? ['valid' => false, 'reason' => 'Unknown Failure'] : false;
    }
}
