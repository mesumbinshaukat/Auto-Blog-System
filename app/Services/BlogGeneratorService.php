<?php

namespace App\Services;

use App\Models\Blog;
use App\Models\Category;
use Illuminate\Support\Str;
use Illuminate\Support\Facades\Log;

class BlogGeneratorService
{
    protected $scraper;
    protected $ai;
    protected $thumbnailService;
    protected $titleSanitizer;

    public function __construct(
        ScrapingService $scraper, 
        AIService $ai, 
        \App\Services\ThumbnailService $thumbnailService,
        TitleSanitizerService $titleSanitizer
    )
    {
        $this->scraper = $scraper;
        $this->ai = $ai;
        $this->thumbnailService = $thumbnailService;
        $this->titleSanitizer = $titleSanitizer;
    }

    public function generateBlogForCategory(Category $category, ?callable $onProgress = null)
    {
        $onProgress && $onProgress('Scraping trending topics...', 10);
        // 1. Get Topics
        $topics = $this->scraper->fetchTrendingTopics($category->slug);
        $topic = $topics[array_rand($topics)];

        // Check duplicates
        if (Blog::where('title', 'LIKE', "%$topic%")->exists()) {
            Log::info("Skipping duplicate topic: $topic");
            $onProgress && $onProgress('Duplicate topic found, retrying...', 15);
            return null;
        }

        $onProgress && $onProgress("Researching topic: $topic...", 30);
        // 2. Multi-Source Research
        Log::info("Researching topic: $topic");
        $researchData = $this->scraper->researchTopic($topic);
        
        $onProgress && $onProgress('Generating draft with AI...', 50);
        // 3. Generate Draft with new AI service
        $draft = $this->ai->generateRawContent($topic, $category->name, $researchData);

        $onProgress && $onProgress('Optimizing and humanizing content...', 70);
        // 4. Optimize and Humanize (returns ['content' => string, 'toc' => array])
        $optimizedData = $this->ai->optimizeAndHumanize($draft);
        $finalContent = $optimizedData['content'];
        $toc = $optimizedData['toc'];
        
        // 5. Validate content
        $wordCount = str_word_count(strip_tags($finalContent));
        Log::info("Blog generated: $wordCount words");
        
        // 5c. Link Management & Validation
        // Validate external links generated by AI
        $cleanedData = $this->validateAndCleanLinks($finalContent);
        $finalContent = $cleanedData['html'];
        
        // Internal Linking (Balance with External)
        // Count current external links
        $externalLinkCount = substr_count($finalContent, 'href="http');
        
        // Cap total links to 8 (so if 3 external, we can add up to 5 internal, but we limit internal to 3 anyway)
        $limitInternal = min(3, 8 - $externalLinkCount);
        
        if ($limitInternal > 0) {
            $relatedBlogs = Blog::where('category_id', $category->id)
                ->where('id', '!=', $category->id) 
                ->latest()
                ->take($limitInternal)
                ->get();
                
            if ($relatedBlogs->count() > 0) {
                 $internalData = $this->insertInternalLinks($finalContent, $relatedBlogs);
                 $finalContent = $internalData['html'];
            }
        }

        // 6. Extract Title
        $title = $topic;
        if (preg_match('/<h1[^>]*>(.*?)<\/h1>/', $finalContent, $matches)) {
            $title = strip_tags($matches[1]);
        }
        
        // Sanitize title to remove entities
        $title = $this->titleSanitizer->sanitizeTitle($title);

        // 7. Generate slug
        $slug = Str::slug($title . '-' . now()->timestamp);

        // 8. Create Blog record first to get ID
        $onProgress && $onProgress('Saving initial record...', 85);
        $blog = Blog::create([
            'title' => $title,
            'slug' => $slug,
            'content' => $finalContent,
            'category_id' => $category->id,
            'published_at' => now(),
             // Enhanced SEO Meta
            'meta_title' => Str::limit($title, 55) . ' - ' . config('app.name', 'AutoBlog'),
            'meta_description' => Str::limit(strip_tags($finalContent), 155),
            'tags_json' => [$category->name, 'Trending', $topic, date('Y')],
            'table_of_contents_json' => $toc,
            'thumbnail_path' => null, // Placeholder
        ]);

        $onProgress && $onProgress('Generating thumbnail...', 90);
        // 9. Generate thumbnail with ID
        $thumbnailPath = $this->thumbnailService->generateThumbnail(
            $slug,
            $title,
            $finalContent,
            $category->name,
            $blog->id // Pass the ID
        );

        // 10. Update blog with actual thumbnail
        $blog->update(['thumbnail_path' => $thumbnailPath]);
        
        // Double-check and fix any issues (e.g. if title logic changed post-creation)
        $this->titleSanitizer->fixBlog($blog);
        
        $onProgress && $onProgress('Done!', 100);
        
        return $blog;
    }

    public function processSeoLinks(string $content, Category $category): array
    {
        // 1. Validate & Clean External Links
        $cleanedData = $this->validateAndCleanLinks($content);
        $content = $cleanedData['html'];
        $externalCount = $cleanedData['count'];
        
        // 2. Insert Internal Links if room
        $externalLinkCount = substr_count($content, 'href="http');
        $limitInternal = min(3, 8 - $externalLinkCount);
        $internalCount = 0;
        
        if ($limitInternal > 0) {
            $relatedBlogs = Blog::where('category_id', $category->id)
                ->where('id', '!=', $category->id)
                ->latest()
                ->take($limitInternal)
                ->get();
                
            if ($relatedBlogs->count() > 0) {
                 $internalData = $this->insertInternalLinks($content, $relatedBlogs);
                 $content = $internalData['html'];
                 $internalCount = $internalData['count'];
            }
        }
        
        return [
            'html' => $content,
            'external_count' => $externalCount,
            'internal_count' => $internalCount
        ];
    }

    protected function insertInternalLinks(string $html, $relatedBlogs): array
    {
        if ($relatedBlogs->isEmpty()) {
            return ['html' => $html, 'count' => 0];
        }

        $dom = new \DOMDocument();
        libxml_use_internal_errors(true);
        $dom->loadHTML('<?xml encoding="utf-8" ?>' . $html, LIBXML_HTML_NOIMPLIED | LIBXML_HTML_NODEFDTD);
        libxml_clear_errors();
        
        $paragraphs = $dom->getElementsByTagName('p');
        $pCount = $paragraphs->length;
        $injectedCount = 0;
        
        // Distribute links: one after 1st para, one in middle, one near end (approx)
        $positions = [
            1, 
            (int)($pCount / 2), 
            $pCount - 2
        ];
        
        $blogIndex = 0;
        
        foreach ($positions as $index) {
             if ($blogIndex >= $relatedBlogs->count()) break;
             if ($index < 0 || $index >= $pCount) continue;
             
             $targetP = $paragraphs->item($index);
             if ($targetP) {
                 $blog = $relatedBlogs[$blogIndex];
                 
                 // Create link phrasing
                 $phrases = [
                     "For more details, check out <a href='%s' rel='dofollow'>%s</a>.",
                     "You might also like: <a href='%s' rel='dofollow'>%s</a>.",
                     "Related reading: <a href='%s' rel='dofollow'>%s</a>."
                 ];
                 $phrase = sprintf($phrases[$blogIndex % 3], route('blog.show', $blog->slug), $blog->title);
                 
                 $newP = $dom->createElement('p');
                 // Load HTML fragment for the link
                 $frag = $dom->createDocumentFragment();
                 $frag->appendXML("<em>$phrase</em>");
                 $newP->appendChild($frag);
                 
                 $targetP->parentNode->insertBefore($newP, $targetP->nextSibling);
                 $blogIndex++;
                 $injectedCount++;
             }
        }
        
        $fixed = $dom->saveHTML();
        return [
            'html' => str_replace('<?xml encoding="utf-8" ?>', '', $fixed),
            'count' => $injectedCount
        ];
    }

    protected function validateAndCleanLinks(string $html): array
    {
        $dom = new \DOMDocument();
        libxml_use_internal_errors(true);
        // Ensure UTF-8 is handled correctly
        $dom->loadHTML('<?xml encoding="utf-8" ?>' . $html, LIBXML_HTML_NOIMPLIED | LIBXML_HTML_NODEFDTD);
        libxml_clear_errors();
        
        $xpath = new \DOMXPath($dom);
        $links = $xpath->query('//a');
        $validLinksCount = 0;
        $maxExternal = 4;
        
        foreach ($links as $link) {
            $href = $link->getAttribute('href');
            
            // Skip internal or empty links
            if (empty($href) || str_starts_with($href, '/') || str_starts_with($href, '#') || str_contains($href, config('app.url'))) {
                continue;
            }
            
            // Validate URL (Headless check)
            if ($this->isValidUrl($href)) {
                $validLinksCount++;
                // Ensure dofollow
                $link->setAttribute('rel', 'dofollow');
                $link->setAttribute('target', '_blank'); // Safety
                
                // Cap external links
                if ($validLinksCount > $maxExternal) {
                    // Convert to plain text if over limit
                    $text = $dom->createTextNode($link->textContent);
                    $link->parentNode->replaceChild($text, $link);
                    $validLinksCount--; // Adjust count as we removed it
                }
            } else {
                // Remove invalid link, keep text
                Log::warning("Removing invalid link: $href");
                $text = $dom->createTextNode($link->textContent);
                $link->parentNode->replaceChild($text, $link);
            }
        }
        
        $fixed = $dom->saveHTML();
        return [
            'html' => str_replace('<?xml encoding="utf-8" ?>', '', $fixed),
            'count' => $validLinksCount
        ];
    }
    
    protected function isValidUrl(string $url): bool
    {
        // Simple filter var check first
        if (!filter_var($url, FILTER_VALIDATE_URL)) return false;
        
        // Perform a quick HEAD request
        try {
             // Use stream context for timeout
            $context = stream_context_create([
                'http' => ['method' => 'HEAD', 'timeout' => 2, 'ignore_errors' => true]
            ]);
            $headers = @get_headers($url, 0, $context);
            if ($headers && strpos($headers[0], '200') !== false) {
                return true;
            }
             // Allow 301/302 redirects too?
            if ($headers && (strpos($headers[0], '301') !== false || strpos($headers[0], '302') !== false)) {
                 return true;
            }
        } catch (\Exception $e) {
            return false;
        }
        
        return false;
    }
}
